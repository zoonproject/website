<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/integration"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:int-jpa="http://www.springframework.org/schema/integration/jpa"
             xmlns:task="http://www.springframework.org/schema/task"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                                 http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-4.0.xsd
                                 http://www.springframework.org/schema/integration/jpa http://www.springframework.org/schema/integration/jpa/spring-integration-jpa-4.0.xsd
                                 http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd">

  <beans:description>
    <![CDATA[
    Business manager main SI context for simulation run request processing.
    ]]>
  </beans:description>

  <!-- Initial phase of handling simulation processing derived from a request ++++++++++++++++++ -->

  <channel id="channel_toRetrievedSimulationsSplitter" />

  <!-- Every 5 seconds select Simulation requests which haven't been processed (i.e. their
       "processed" property is "false"). The Simulations were written here by the request 
       processor. -->
  <int-jpa:inbound-channel-adapter channel="channel_toRetrievedSimulationsSplitter"
                                   entity-manager-factory="businessEntityManagerFactory"
                                   id="processRequest_inboundChannelAdapter"
                                   named-query="simulation.queryByRequestProcessed">
    <poller fixed-rate="5"
            time-unit="SECONDS">
      <transactional read-only="true"
                     transaction-manager="businessTransactionManager" />
    </poller>
  </int-jpa:inbound-channel-adapter>

  <!-- Splitters normally work sequentially - use a dispatcher to create separate threads to allow
       parallel processing (but keep in mind that transactions cannot be propagated to new threads,
       so the read-only transaction used by the int-jpa:inbound-channel-adapter will close.
       Note also that there may be a collection of Simulation objects for processing, so that's why
       there's a splitter. -->
  <!-- pool-size : 4 core threads created on-demand, a further 4 created when queue is full.
                 : Threads 5-8 closed if created but subsequently unused for 120 seconds -->
  <task:executor id="toSimulationPayloadEnricherExecutor"
                 pool-size="4-8"
                 queue-capacity="10"
                 keep-alive="120" />
  <channel id="executorChannel_toSimulationProcessingInitiator"
           datatype="uk.ac.ox.cs.science2020.zoon.business_manager.entity.Simulation">
    <dispatcher task-executor="toSimulationPayloadEnricherExecutor" />
  </channel>

  <!-- Split (potentially) Simulations into individual processing threads, each containing an 
       individual Simulation. -->
  <splitter id="retrievedSimulationsSplitter"
            input-channel="channel_toRetrievedSimulationsSplitter"
            output-channel="executorChannel_toSimulationProcessingInitiator" />

  <!-- Initiate the simulation processing. -->
  <service-activator id="srvactSimulationProcessingInitiator"
                     input-channel="executorChannel_toSimulationProcessingInitiator"
                     method="initiateSimulationProcessing">
    <beans:bean class="uk.ac.ox.cs.science2020.zoon.business_manager.business.SimulationProcessingInitiator" />
  </service-activator>

</beans:beans>